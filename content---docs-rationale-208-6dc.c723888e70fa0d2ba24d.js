(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{46:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return p}));n(0);var a=n(64);function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i={id:"rationale",title:"Rationale"},s=[{value:"Why not async generators?",id:"why-not-async-generators",children:[]},{value:"Why not observables?",id:"why-not-observables",children:[]}],c={rightToc:s},l="wrapper";function p(e){var t=e.components,n=o(e,["components"]);return Object(a.b)(l,r({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"While ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/tc39/proposal-async-iteration"}),"async iterators")," are available in most modern javascript runtimes, they have yet to achieve widespread usage due to various perceived ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/apollographql/graphql-subscriptions/issues/116"}),"flaws")," and ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/tc39/proposal-async-iteration/issues/126"}),"pitfalls"),". What’s needed is something like the ",Object(a.b)("inlineCode",{parentName:"p"},"Promise")," constructor, which helped promises succeed by providing a common pattern for converting callback-based APIs into promises. Correspondingly, the ",Object(a.b)("inlineCode",{parentName:"p"},"Repeater")," constructor makes it easy to turn ",Object(a.b)("em",{parentName:"p"},"any")," callback-based source of data into an async iterator, and prevents common async iterator mistakes ",Object(a.b)("a",r({parentName:"p"},{href:"/docs/safety"}),"by design"),". The constructor pattern is easy to memorize and adaptable for almost every async iterator use case."),Object(a.b)("h2",{id:"why-not-async-generators"},"Why not async generators?"),Object(a.b)("p",null,"Repeaters are meant to be used alongside async generators rather than replace them. The problem with using async generators exclusively is that they rely on the ",Object(a.b)("inlineCode",{parentName:"p"},"yield"),", ",Object(a.b)("inlineCode",{parentName:"p"},"return")," and ",Object(a.b)("inlineCode",{parentName:"p"},"throw")," operators to produce values, which are unavailable in nested function closures."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"async function* messages(url) {\n  const socket = new WebSocket(url);\n  socket.onmessage = (ev) => {\n    // can’t make the outer generator yield from here.\n    yield ev.data // this line throws a syntax error\n  };\n}\n")),Object(a.b)("p",null,"The solution using async generators exclusively is often to create a ",Object(a.b)("inlineCode",{parentName:"p"},"while (true)")," loop which awaits a newly constructed promise, adding and removing event handlers each iteration. The resulting code is prone to race-conditions, dropped messages and memory leaks unless done with an expert understanding of both promises and generators. Repeaters behave identically to async generators, except they provide the ",Object(a.b)("inlineCode",{parentName:"p"},"yield"),", ",Object(a.b)("inlineCode",{parentName:"p"},"return")," and ",Object(a.b)("inlineCode",{parentName:"p"},"throw")," operators as the functions ",Object(a.b)("inlineCode",{parentName:"p"},"push")," and ",Object(a.b)("inlineCode",{parentName:"p"},"stop"),". These functions can be used in child closures, making repeaters ideal for use with callback-based APIs."),Object(a.b)("p",null,"Once you have converted callback-based APIs to repeater-returning functions, repeaters can be used seamlessly with async generators to write elegant async code."),Object(a.b)("h2",{id:"why-not-observables"},"Why not observables?"),Object(a.b)("p",null,"Observables are often thought of as competing with async iterators and therefore repeaters, and most repeater code can be rewritten with observables. Here, for instance, is the ",Object(a.b)("a",r({parentName:"p"},{href:"quickstart#konami-code"}),"Konami example from the quickstart"),", rewritten using ",Object(a.b)("inlineCode",{parentName:"p"},"rxjs"),":"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'import { Observable } from "rxjs";\nimport { takeWhile } from "rxjs/operators";\nconst keys = new Observable((subscriber) => {\n  const listener = (ev) => {\n    if (ev.key === "Escape") {\n      subscriber.complete();\n    } else {\n      subscriber.next(ev.key);\n    }\n  };\n  window.addEventListener("keyup", listener);\n  return () => window.removeEventListener("keyup", listener);\n});\n\nconst konami = ["ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowLeft", "ArrowRight", "ArrowLeft", "ArrowRight", "b", "a"];\n\nlet i = 0;\nlet subscription = keys\n  .pipe(\n    takeWhile((key) => {\n      if (key === konami[i]) {\n        i++;\n      } else {\n        i = 0;\n      }\n      if (i >= konami.length) {\n        console.log("KONAMI!!!");\n        return false;\n      }\n      return true;\n    }),\n  )\n  .subscribe();\n')),Object(a.b)("p",null,"While you can often create an equivalent observable for any repeater, there are differences which make repeaters more convenient to use."),Object(a.b)("p",null,"Firstly, repeaters support ",Object(a.b)("inlineCode",{parentName:"p"},"async/await")," and ",Object(a.b)("inlineCode",{parentName:"p"},"for await…of")," syntax out of the box, so we don’t need a library of “operators” like ",Object(a.b)("inlineCode",{parentName:"p"},"takeWhile")," to consume them. In the example above, someone unfamiliar with ",Object(a.b)("inlineCode",{parentName:"p"},"rxjs")," might not immediately recognize what ",Object(a.b)("inlineCode",{parentName:"p"},"takeWhile")," does, whereas the same programmer would probably recognize what a ",Object(a.b)("inlineCode",{parentName:"p"},"break")," statement does in a ",Object(a.b)("inlineCode",{parentName:"p"},"for await…of")," loop. Using ",Object(a.b)("inlineCode",{parentName:"p"},"for")," loops means we get to leverage what we already know about synchronous loops and control-flow operators to write cleaner, more intuitive code."),Object(a.b)("p",null,"Secondly, despite the claims observable advocates make about how observables are “monadic” or that they are the “mathematical dual” of synchronous iterators, observables are ultimately callback-based APIs. The above example hides this detail by calling the ",Object(a.b)("inlineCode",{parentName:"p"},"subscribe")," method without arguments, but if we wanted to compose this observable with other code, we would have to make additional calls to ",Object(a.b)("inlineCode",{parentName:"p"},"pipe"),", passing in additional callbacks. While these calls to ",Object(a.b)("inlineCode",{parentName:"p"},"pipe")," can be combined using “higher-order observable operators,” the resulting code can be difficult to understand or split up into reasonably named functions. The most natural asynchronous analogue to sync iterators are async iterators."))}p.isMDXComponent=!0},64:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return b}));var a=n(0),r=n.n(a),o=r.a.createContext({}),i=function(e){var t=r.a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},s=function(e){var t=i(e.components);return r.a.createElement(o.Provider,{value:t},e.children)};var c="mdxType",l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},p=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}(e,["components","mdxType","originalType","parentName"]),p=i(n),b=a,u=p[s+"."+b]||p[b]||l[b]||o;return n?r.a.createElement(u,Object.assign({},{ref:t},c,{components:n})):r.a.createElement(u,Object.assign({},{ref:t},c))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,i[1]=s;for(var b=2;b<o;b++)i[b]=n[b];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);