(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{40:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",function(){return s}),n.d(t,"rightToc",function(){return i}),n.d(t,"default",function(){return p});n(0);var a=n(58);function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s={id:"rationale",title:"Rationale"},i=[{value:"Why not async generators?",id:"why-not-async-generators",children:[]},{value:"Why not observables?",id:"why-not-observables",children:[]}],c={rightToc:i},l="wrapper";function p(e){var t=e.components,n=o(e,["components"]);return Object(a.b)(l,r({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"While ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/tc39/proposal-async-iteration"}),"async iterators")," are available in most modern javascript runtimes, they have yet to achieve widespread usage due to various perceived ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/apollographql/graphql-subscriptions/issues/116"}),"flaws")," and ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/tc39/proposal-async-iteration/issues/126"}),"pitfalls"),". What’s needed is something like the ",Object(a.b)("inlineCode",{parentName:"p"},"Promise")," constructor, which helped promises succeed by providing a common pattern for converting callback-based APIs into promises. The ",Object(a.b)("inlineCode",{parentName:"p"},"Repeater")," constructor makes it easy to turn ",Object(a.b)("em",{parentName:"p"},"any")," callback-based source of data into an async iterator, and prevents common async iterator mistakes ",Object(a.b)("a",r({parentName:"p"},{href:"safety"}),"by design"),". The constructor pattern is easy to memorize and adaptable for almost every async iterator use case."),Object(a.b)("h2",{id:"why-not-async-generators"},"Why not async generators?"),Object(a.b)("p",null,"Repeaters are meant to be used alongside async generators rather than replace them. The problem with using async generators exclusively is that they rely on the ",Object(a.b)("inlineCode",{parentName:"p"},"yield"),", ",Object(a.b)("inlineCode",{parentName:"p"},"return")," and ",Object(a.b)("inlineCode",{parentName:"p"},"throw")," statements to produce values, which are unavailable in child closures. "),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"async function* messages(url) {\n  const socket = new WebSocket(url);\n  socket.onmessage = (ev) => {\n     // can’t make the outer generator yield from here.\n  };\n}\n")),Object(a.b)("p",null,"The solution using async generators is often some ad-hoc ",Object(a.b)("inlineCode",{parentName:"p"},"while (true)")," loop which awaits a newly constructed promise which adds and removes event handlers for each iteration. The resulting code is often prone to race-conditions, dropped messages and memory leaks unless done with an expert understanding of both promises and generators. Repeaters behave identically to async generators, except they provide the ",Object(a.b)("inlineCode",{parentName:"p"},"yield"),", ",Object(a.b)("inlineCode",{parentName:"p"},"return")," and ",Object(a.b)("inlineCode",{parentName:"p"},"throw")," statements as the functions ",Object(a.b)("inlineCode",{parentName:"p"},"push")," and ",Object(a.b)("inlineCode",{parentName:"p"},"stop"),". These functions give imperative control over repeaters in child closures, making repeaters ideal for use with callback-based APIs."),Object(a.b)("p",null,"Once you have converted callback-based APIs to repeater-returning functions, repeaters can be used seamlessly with async generators to write easy-to-understand async code."),Object(a.b)("h2",{id:"why-not-observables"},"Why not observables?"),Object(a.b)("p",null,"Observables are often thought of as competing with async iterators and therefore repeaters, and it’s true that most repeater code can be rewritten with observables. Here, for instance, is the ",Object(a.b)("a",r({parentName:"p"},{href:"quickstart#listening-for-the-konami-code"}),"Konami example from the quickstart"),", rewritten using ",Object(a.b)("inlineCode",{parentName:"p"},"rxjs"),":"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'import { Observable } from "rxjs";\nimport { takeWhile } from "rxjs/operators";\nconst keys = new Observable(subscriber => {\n  const listener = ev => {\n    if (ev.key === "Escape") {\n      subscriber.complete();\n    } else {\n      subscriber.next(ev.key);\n    }\n  };\n  window.addEventListener("keyup", listener);\n  return () => window.removeEventListener("keyup", listener);\n});\n\nconst konami = ["ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowLeft", "ArrowRight", "ArrowLeft", "ArrowRight", "b", "a"];\n\nlet i = 0;\nlet subscription = keys\n  .pipe(\n    takeWhile(key => {\n      if (key === konami[i]) {\n        i++;\n      } else {\n        i = 0;\n      }\n      if (i >= konami.length) {\n        console.log("KONAMI!!!");\n        return false;\n      }\n      return true;\n    }),\n  )\n  .subscribe();\n')),Object(a.b)("p",null,"While you can often create an equivalent observable for any repeater, there are several differences that make repeaters much nicer to use."),Object(a.b)("p",null,"Firstly, repeaters support ",Object(a.b)("inlineCode",{parentName:"p"},"async"),"/",Object(a.b)("inlineCode",{parentName:"p"},"await")," and ",Object(a.b)("inlineCode",{parentName:"p"},"for await…of")," syntax, so we don’t need a library of “operators” like ",Object(a.b)("inlineCode",{parentName:"p"},"takeWhile")," to consume repeaters. To someone unfamiliar with ",Object(a.b)("inlineCode",{parentName:"p"},"rxjs"),", it might not be immediately obvious in the example what ",Object(a.b)("inlineCode",{parentName:"p"},"takeWhile")," does, whereas the same programmer would probably recognize what a ",Object(a.b)("inlineCode",{parentName:"p"},"break")," statement does in a ",Object(a.b)("inlineCode",{parentName:"p"},"for await…of")," loop. Using ",Object(a.b)("inlineCode",{parentName:"p"},"for await…of")," loops means we get to leverage what we already know about synchronous loops and control-flow statements to write cleaner, more intuitive code. Rather than using the ",Object(a.b)("inlineCode",{parentName:"p"},"map")," operator, we can assign a variable, rather than using the ",Object(a.b)("inlineCode",{parentName:"p"},"filter")," operator, we can use ",Object(a.b)("inlineCode",{parentName:"p"},"if"),"/",Object(a.b)("inlineCode",{parentName:"p"},"else")," statements, and rather than using the ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," operator, we can reassign or mutate a variable in the outer scope. I suspect that if observables ever ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/ReactiveX/rxjs/issues/4002"}),"decided to support the async iterator protocol"),", the market for higher-order observable functions would collapse overnight."),Object(a.b)("p",null,"Secondly, despite the claims observable advocates make about how observables are “monadic” or that they are the “mathematical dual” of synchronous iterables, observables are ultimately callback-based APIs. The above example hides this detail by calling the ",Object(a.b)("inlineCode",{parentName:"p"},"subscribe")," method without arguments, but if we wanted to compose this observable with other code, we would have to call other observable methods, which take callbacks. Being a callback-based API makes using observables with ",Object(a.b)("inlineCode",{parentName:"p"},"async"),"/",Object(a.b)("inlineCode",{parentName:"p"},"await")," and promises awkward; in fact, observables suffer from the same issue of “callback hell” which promises were designed to solve. Observable libraries are aware of this and provide “higher-order observable operators,” which work on observables of observables, but these solutions are seldom used and virtually incomprehensible to human beings, who are unaccustomed to thinking in extradimensional spaces."))}p.isMDXComponent=!0},58:function(e,t,n){"use strict";n.d(t,"a",function(){return i}),n.d(t,"b",function(){return b});var a=n(0),r=n.n(a),o=r.a.createContext({}),s=function(e){var t=r.a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},i=function(e){var t=s(e.components);return r.a.createElement(o.Provider,{value:t},e.children)};var c="mdxType",l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},p=function(e){var t=e.components,n=e.mdxType,a=e.originalType,o=e.parentName,i=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}(e,["components","mdxType","originalType","parentName"]),c=s(t),p=n,b=c[o+"."+p]||c[p]||l[p]||a;return t?r.a.createElement(b,Object.assign({},i,{components:t})):r.a.createElement(b,i)};function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[c]="string"==typeof e?e:a,s[1]=i;for(var b=2;b<o;b++)s[b]=n[b];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);